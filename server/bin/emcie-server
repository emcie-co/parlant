#!/usr/bin/python3

import asyncio
from contextlib import asynccontextmanager, AsyncExitStack
from dataclasses import dataclass
from datetime import datetime, timezone
from enum import Enum, auto
import os
from fastapi import FastAPI
from lagom import Container
from typing import Any, AsyncIterator, Awaitable, Callable
import click
import click_completion
import json
from loguru import logger
from pathlib import Path
import sys
import rich
from rich.text import Text
from tabulate import tabulate
import uvicorn

from emcie.server.api.app import create_app
from emcie.server.core.agents import AgentDocumentStore, AgentStore
from emcie.server.core.context_variables import ContextVariableDocumentStore, ContextVariableStore
from emcie.server.core.end_users import EndUserDocumentStore, EndUserStore
from emcie.server.core.guideline_connections import (
    GuidelineConnectionDocumentStore,
    GuidelineConnectionStore,
)
from emcie.server.core.guidelines import (
    Guideline,
    GuidelineDocumentStore,
    GuidelineId,
    GuidelineStore,
)
from emcie.server.core.persistence.chroma_database import ChromaDatabase
from emcie.server.core.persistence.json_file_database import JSONFileDocumentDatabase
from emcie.server.core.sessions import (
    PollingSessionListener,
    SessionDocumentStore,
    SessionListener,
    SessionStore,
)
from emcie.server.core.terminology import TerminologyChromaStore, TerminologyStore
from emcie.server.core.tools import LocalToolService, ToolService, MultiplexedToolService
from emcie.server.core.plugins import PluginClient
from emcie.server.coherence_checker import CoherenceChecker
from emcie.server.engines.alpha.engine import AlphaEngine
from emcie.server.core.guideline_tool_associations import (
    GuidelineToolAssociationDocumentStore,
    GuidelineToolAssociationStore,
)
from emcie.server.engines.common import Engine
from emcie.server.mc import MC
from emcie.server.configuration_validator import ConfigurationFileValidator

DEFAULT_PORT = 8000

EMCIE_HOME_DIR = Path(os.environ.get("EMCIE_HOME", "/var/lib/emcie"))
EMCIE_HOME_DIR.mkdir(parents=True, exist_ok=True)

MULTIPLEXED_TOOL_SERVICE = MultiplexedToolService()
TOOL_NAME_TO_ID: dict[str, str] = {}

EXIT_STACK: AsyncExitStack

sys.path.append(EMCIE_HOME_DIR.as_posix())

logger.info(f"Using home directory '{EMCIE_HOME_DIR.absolute()}'")


@dataclass
class CLIParams:
    config_file: Path
    config: dict[str, Any]
    port: int


class ShutdownReason(Enum):
    HOT_RELOAD = auto()
    SHUTDOWN_REQUEST = auto()


async def load_agents(c: Container, config: Any) -> None:
    store = c[AgentStore]
    existing_agents = await store.list_agents()

    for agent in config["agents"]:
        if not [a for a in existing_agents if a.name == agent["name"]]:
            await store.create_agent(
                name=agent["name"],
                description=agent.get("description"),
            )


async def load_tools(c: Container, config: Any) -> None:
    local_tool_service = c[LocalToolService]

    for service in config["services"]:
        if service["type"] == "local":
            for tool_name, tool in service["tools"].items():
                tool = await local_tool_service.create_tool(
                    name=tool["function_name"],
                    module_path=tool["module_path"],
                    description=tool["description"],
                    parameters=tool["parameters"],
                    required=tool["required"],
                    consequential=False,
                )

                TOOL_NAME_TO_ID[tool_name] = tool.id
        elif service["type"] == "plugin":
            name = service["name"]
            url = service["url"]

            client = PluginClient(url)
            await EXIT_STACK.enter_async_context(client)

            MULTIPLEXED_TOOL_SERVICE.services[name] = client


async def load_guidelines(c: Container, config: Any) -> None:
    agent_store = c[AgentStore]
    guideline_store = c[GuidelineStore]
    guideline_tool_association_store = c[GuidelineToolAssociationStore]

    agents = await agent_store.list_agents()

    for agent_name, guidelines in config["guidelines"].items():
        agent_id = next(a.id for a in agents if a.name == agent_name)

        for guideline_spec in guidelines:
            guideline = await guideline_store.create_guideline(
                guideline_set=agent_id,
                predicate=guideline_spec["when"],
                content=guideline_spec["then"],
            )

            for tool_name in guideline_spec.get("enabled_tools", []):
                await guideline_tool_association_store.create_association(
                    guideline_id=guideline.id,
                    tool_id=TOOL_NAME_TO_ID.get(tool_name, tool_name),
                )


@asynccontextmanager
async def setup_container(config: Any) -> AsyncIterator[Container]:
    TOOL_NAME_TO_ID.clear()
    MULTIPLEXED_TOOL_SERVICE.services.clear()

    for store_name in [
        "guidelines",
        "tools",
        "guideline_tool_associations",
        "context_variables",
    ]:
        (EMCIE_HOME_DIR / f"{store_name}.json").unlink(missing_ok=True)

    c = Container()

    async with JSONFileDocumentDatabase(
        EMCIE_HOME_DIR / "agents.json"
    ) as agents_db, JSONFileDocumentDatabase(
        EMCIE_HOME_DIR / "context_variables.json"
    ) as context_variables_db, JSONFileDocumentDatabase(
        EMCIE_HOME_DIR / "end_users.json"
    ) as end_users_db, JSONFileDocumentDatabase(
        EMCIE_HOME_DIR / "sessions.json",
    ) as sessions_db, JSONFileDocumentDatabase(
        EMCIE_HOME_DIR / "guidelines.json"
    ) as guidelines_db, JSONFileDocumentDatabase(
        EMCIE_HOME_DIR / "tools.json"
    ) as tools_db, JSONFileDocumentDatabase(
        EMCIE_HOME_DIR / "guideline_tool_associations.json"
    ) as guideline_tool_associations_db, JSONFileDocumentDatabase(
        EMCIE_HOME_DIR / "guideline_connections.json"
    ) as guideline_connections_db:
        c[AgentStore] = AgentDocumentStore(agents_db)
        c[ContextVariableStore] = ContextVariableDocumentStore(context_variables_db)
        c[EndUserStore] = EndUserDocumentStore(end_users_db)
        c[GuidelineStore] = GuidelineDocumentStore(guidelines_db)

        c[LocalToolService] = LocalToolService(tools_db)
        MULTIPLEXED_TOOL_SERVICE.services["local"] = c[LocalToolService]
        c[ToolService] = MULTIPLEXED_TOOL_SERVICE

        c[GuidelineToolAssociationStore] = GuidelineToolAssociationDocumentStore(
            guideline_tool_associations_db
        )
        c[GuidelineConnectionStore] = GuidelineConnectionDocumentStore(guideline_connections_db)
        c[SessionStore] = SessionDocumentStore(sessions_db)

        c[TerminologyStore] = TerminologyChromaStore(ChromaDatabase(EMCIE_HOME_DIR))

        c[SessionListener] = PollingSessionListener
        c[Engine] = AlphaEngine

        for loader in load_agents, load_tools, load_guidelines:
            await loader(c, config)

        async with MC(c) as mc:
            c[MC] = mc
            yield c


@asynccontextmanager
async def load_app(config: Any) -> AsyncIterator[FastAPI]:
    global EXIT_STACK

    EXIT_STACK = AsyncExitStack()

    async with setup_container(config) as container, EXIT_STACK:
        yield await create_app(container)


async def serve_app(
    app: FastAPI,
    port: int,
    should_hot_reload: Callable[[], Awaitable[bool]],
) -> ShutdownReason:
    config = uvicorn.Config(app, host="0.0.0.0", port=port, log_level="info")
    server = uvicorn.Server(config)
    interrupted = False

    async def monitor_shutdown_request() -> ShutdownReason:
        try:
            while True:
                await asyncio.sleep(1)

                if await should_hot_reload():
                    server.should_exit = True
                    return ShutdownReason.HOT_RELOAD
                elif interrupted:
                    return ShutdownReason.SHUTDOWN_REQUEST
        except asyncio.CancelledError:
            return ShutdownReason.SHUTDOWN_REQUEST

    shutdown_monitor_task = asyncio.create_task(monitor_shutdown_request())

    try:
        await server.serve()
        interrupted = True
    except (KeyboardInterrupt, asyncio.CancelledError):
        return ShutdownReason.SHUTDOWN_REQUEST
    except BaseException as e:
        logger.critical(e.__class__.__name__ + ": " + str(e))
        sys.exit(1)

    return await shutdown_monitor_task


async def start_server(params: CLIParams) -> None:
    assert ConfigurationFileValidator().validate(config_file=params.config_file)

    last_config_update_time = os.path.getmtime(params.config_file)

    async def config_file_changed() -> bool:
        nonlocal last_config_update_time
        current_mtime = os.path.getmtime(params.config_file)

        if current_mtime > last_config_update_time:
            validated = ConfigurationFileValidator().validate(config_file=params.config_file)

            last_config_update_time = current_mtime

            return validated

        return False

    while True:
        async with load_app(params.config) as app:
            shutdown_reason = await serve_app(
                app,
                params.port,
                should_hot_reload=config_file_changed,
            )

            if shutdown_reason == ShutdownReason.SHUTDOWN_REQUEST:
                return
            elif shutdown_reason == ShutdownReason.HOT_RELOAD:
                logger.info("***** HOT RELOAD *****")

                with open(params.config_file) as f:
                    params.config = json.load(f)
                    last_config_update_time = os.path.getmtime(params.config_file)


async def check_coherence(params: CLIParams) -> None:
    def render_guideline(g: Guideline) -> str:
        return f"When {g.predicate}, then {g.content}"

    checker = CoherenceChecker()

    for agent, guideline_specs in params.config["guidelines"].items():
        guidelines = [
            Guideline(
                id=GuidelineId(str(index)),
                creation_utc=datetime.now(timezone.utc),
                predicate=guideline["when"],
                content=guideline["then"],
            )
            for index, guideline in enumerate(guideline_specs)
        ]

        guidelines_by_id = {g.id: g for g in guidelines}

        tests = [
            t
            for t in await checker.evaluate_coherence(
                proposed_guidelines=guidelines,
                existing_guidelines=[],
            )
            if t.severity >= 6
        ]

        if tests:
            rich.print(Text(f'{len(tests)} issues found in "{agent}"\n', style="bold red"))
            entries = [
                {
                    "first": render_guideline(guidelines_by_id[t.proposed_guideline_id]),
                    "second": render_guideline(guidelines_by_id[t.existing_guideline_id]),
                    "issue": t.rationale,
                    "severity": t.severity,
                }
                for t in tests
            ]
            rich.print(
                tabulate(
                    entries,
                    headers="keys",
                    maxcolwidths=[20, 20, 40, 10],
                    tablefmt="rounded_grid",
                )
            )
            rich.print()


if __name__ == "__main__":
    click_completion.init()

    @click.group
    @click.option(
        "-c",
        "--config-file",
        type=str,
        help="Server configuration file",
        metavar="FILE",
        required=True,
        default=EMCIE_HOME_DIR / "config.json",
    )
    @click.pass_context
    def cli(ctx: click.Context, config_file: str) -> None:
        if not ctx.obj:
            config_file_path = Path(config_file)

            if not config_file_path.exists():
                print(f"error: config file not found: {config_file_path}", file=sys.stderr)
                exit(1)

            with open(config_file_path, "r") as f:
                config = json.load(f)

                ctx.obj = CLIParams(
                    config_file=config_file_path,
                    config=config,
                    port=DEFAULT_PORT,
                )

    @cli.command(help="Run the Emcie server")
    @click.option(
        "-p",
        "--port",
        type=int,
        default=DEFAULT_PORT,
        help="Server port",
    )
    @click.pass_context
    def run(ctx: click.Context, port: int) -> None:
        ctx.obj.port = port
        asyncio.run(start_server(ctx.obj))

    @cli.command(help="Check the configuration's validity and coherence")
    @click.pass_context
    def check(ctx: click.Context) -> None:
        asyncio.run(check_coherence(ctx.obj))

    cli()
