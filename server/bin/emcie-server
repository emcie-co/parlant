#!/usr/bin/python3
# mypy: disable-error-code=import-untyped

import asyncio
from contextlib import asynccontextmanager, AsyncExitStack
from dataclasses import dataclass
from enum import Enum, auto
import os
from fastapi import FastAPI
from lagom import Container
from typing import Any, AsyncIterator, Awaitable, Callable
import click
import click_completion
import json
from pathlib import Path
import sys
import rich
from rich.text import Text
from tabulate import tabulate
import uvicorn

from emcie.common.tools import ToolId
from emcie.server.api.app import create_app
from emcie.server.contextual_correlator import ContextualCorrelator
from emcie.server.core.agents import AgentDocumentStore, AgentStore
from emcie.server.core.context_variables import ContextVariableDocumentStore, ContextVariableStore
from emcie.server.core.end_users import EndUserDocumentStore, EndUserStore
from emcie.server.core.evaluations import EvaluationDocumentStore, EvaluationStatus, EvaluationStore
from emcie.server.core.generation.embedders import Large3Embedder
from emcie.server.core.generation.schematic_generators import (
    BaseSchematicGenerator,
    GPT4o,
    GPT4oMini,
)
from emcie.server.core.guideline_connections import (
    GuidelineConnectionDocumentStore,
    GuidelineConnectionStore,
)
from emcie.server.core.guidelines import (
    GuidelineContent,
    GuidelineDocumentStore,
    GuidelineStore,
)
from emcie.server.core.persistence.chroma_database import ChromaDatabase
from emcie.server.core.persistence.json_file_database import JSONFileDocumentDatabase
from emcie.server.core.sessions import (
    PollingSessionListener,
    SessionDocumentStore,
    SessionListener,
    SessionStore,
)
from emcie.server.core.terminology import TerminologyChromaStore, TerminologyStore
from emcie.server.core.tools import LocalToolService, ToolService, MultiplexedToolService
from emcie.server.core.services.plugins import PluginClient
from emcie.server.engines.alpha.engine import AlphaEngine
from emcie.server.core.guideline_tool_associations import (
    GuidelineToolAssociationDocumentStore,
    GuidelineToolAssociationStore,
)
from emcie.server.engines.alpha.tool_caller import ToolCallInferenceSchema
from emcie.server.engines.alpha.guideline_proposer import (
    GuidelineProposer,
    GuidelinePropositionsSchema,
)
from emcie.server.engines.alpha.message_event_producer import (
    MessageEventProducer,
    MessageEventSchema,
)
from emcie.server.engines.alpha.tool_event_producer import ToolEventProducer
from emcie.server.engines.common import Engine
from emcie.server.indexing.behavioral_change_evaluation import BehavioralChangeEvaluator
from emcie.server.indexing.coherence_checker import CoherenceChecker, ContradictionTestsSchema
from emcie.server.indexing.guideline_connection_proposer import (
    GuidelineConnectionProposer,
    GuidelineConnectionPropositionsSchema,
)
from emcie.server.indexing.indexer import Indexer
from emcie.server.logger import FileLogger, Logger
from emcie.server.mc import MC
from emcie.server.configuration_validator import ConfigurationFileValidator

DEFAULT_PORT = 8000
SERVER_ADDRESS = "https://localhost"

EMCIE_HOME_DIR = Path(os.environ.get("EMCIE_HOME", "/var/lib/emcie"))
EMCIE_HOME_DIR.mkdir(parents=True, exist_ok=True)

MULTIPLEXED_TOOL_SERVICE = MultiplexedToolService()
TOOL_NAME_TO_ID: dict[str, ToolId] = {}

EXIT_STACK: AsyncExitStack

sys.path.append(EMCIE_HOME_DIR.as_posix())


CORRELATOR = ContextualCorrelator()
LOGGER = FileLogger(EMCIE_HOME_DIR / "emcie.log", CORRELATOR)
LOGGER.info(f"Using home directory '{EMCIE_HOME_DIR.absolute()}'")


class StartupError(Exception):
    def __init__(self, message: str) -> None:
        super().__init__(message)


@dataclass
class CLIParams:
    config_file: Path
    config: dict[str, Any]
    port: int
    index: bool
    force: bool


class ShutdownReason(Enum):
    HOT_RELOAD = auto()
    SHUTDOWN_REQUEST = auto()


async def load_agents(c: Container, config: Any) -> None:
    store = c[AgentStore]
    existing_agents = await store.list_agents()

    for agent in config["agents"]:
        if not [a for a in existing_agents if a.name == agent["name"]]:
            await store.create_agent(
                name=agent["name"],
                description=agent.get("description"),
            )


async def load_tools(c: Container, config: Any) -> None:
    local_tool_service = c[LocalToolService]

    for service in config["services"]:
        if service["type"] == "local":
            for tool_name, tool_entry in service["tools"].items():
                tool = await local_tool_service.create_tool(
                    name=tool_entry["function_name"],
                    module_path=tool_entry["module_path"],
                    description=tool_entry["description"],
                    parameters=tool_entry["parameters"],
                    required=tool_entry["required"],
                    consequential=False,
                )

                TOOL_NAME_TO_ID[tool_name] = tool.id
        elif service["type"] == "plugin":
            name = str(service["name"])
            url = str(service["url"])

            client = PluginClient(url)
            await EXIT_STACK.enter_async_context(client)

            MULTIPLEXED_TOOL_SERVICE.add_service(name, client)


async def load_guidelines(c: Container, config: Any) -> None:
    agent_store = c[AgentStore]
    guideline_store = c[GuidelineStore]
    guideline_tool_association_store = c[GuidelineToolAssociationStore]

    agents = await agent_store.list_agents()

    for agent_name, guidelines in config["guidelines"].items():
        agent_id = next(a.id for a in agents if a.name == agent_name)

        for guideline_spec in guidelines:
            guideline = await guideline_store.create_guideline(
                guideline_set=agent_id,
                predicate=guideline_spec["when"],
                action=guideline_spec["then"],
            )

            for tool_name in guideline_spec.get("enabled_tools", []):
                await guideline_tool_association_store.create_association(
                    guideline_id=guideline.id,
                    tool_id=TOOL_NAME_TO_ID.get(tool_name, ToolId(tool_name)),
                )


@asynccontextmanager
async def setup_container(config: Any) -> AsyncIterator[Container]:
    TOOL_NAME_TO_ID.clear()
    MULTIPLEXED_TOOL_SERVICE.services.clear()

    for store_name in [
        "guidelines",
        "tools",
        "guideline_tool_associations",
        "context_variables",
    ]:
        (EMCIE_HOME_DIR / f"{store_name}.json").unlink(missing_ok=True)

    c = Container()

    c[ContextualCorrelator] = CORRELATOR
    c[Logger] = LOGGER

    c[BaseSchematicGenerator[GuidelinePropositionsSchema]] = GPT4o(
        logger=c[Logger], schema=GuidelinePropositionsSchema
    )
    c[BaseSchematicGenerator[MessageEventSchema]] = GPT4o(
        logger=c[Logger], schema=MessageEventSchema
    )
    c[BaseSchematicGenerator[ToolCallInferenceSchema]] = GPT4oMini(
        logger=c[Logger], schema=ToolCallInferenceSchema
    )
    c[BaseSchematicGenerator[ContradictionTestsSchema]] = GPT4o(
        logger=c[Logger], schema=ContradictionTestsSchema
    )
    c[BaseSchematicGenerator[GuidelineConnectionPropositionsSchema]] = GPT4o(
        logger=c[Logger], schema=GuidelineConnectionPropositionsSchema
    )

    async with (
        JSONFileDocumentDatabase(LOGGER, EMCIE_HOME_DIR / "agents.json") as agents_db,
        JSONFileDocumentDatabase(
            LOGGER, EMCIE_HOME_DIR / "context_variables.json"
        ) as context_variables_db,
        JSONFileDocumentDatabase(LOGGER, EMCIE_HOME_DIR / "end_users.json") as end_users_db,
        JSONFileDocumentDatabase(
            LOGGER,
            EMCIE_HOME_DIR / "sessions.json",
        ) as sessions_db,
        JSONFileDocumentDatabase(LOGGER, EMCIE_HOME_DIR / "guidelines.json") as guidelines_db,
        JSONFileDocumentDatabase(LOGGER, EMCIE_HOME_DIR / "tools.json") as tools_db,
        JSONFileDocumentDatabase(
            LOGGER, EMCIE_HOME_DIR / "guideline_tool_associations.json"
        ) as guideline_tool_associations_db,
        JSONFileDocumentDatabase(
            LOGGER, EMCIE_HOME_DIR / "guideline_connections.json"
        ) as guideline_connections_db,
        JSONFileDocumentDatabase(LOGGER, EMCIE_HOME_DIR / "evaluations.json") as evaluations_db,
    ):
        c[AgentStore] = AgentDocumentStore(agents_db)
        c[ContextVariableStore] = ContextVariableDocumentStore(context_variables_db)
        c[EndUserStore] = EndUserDocumentStore(end_users_db)
        c[GuidelineStore] = GuidelineDocumentStore(guidelines_db)

        c[LocalToolService] = LocalToolService(tools_db)
        MULTIPLEXED_TOOL_SERVICE.services["local"] = c[LocalToolService]
        c[ToolService] = MULTIPLEXED_TOOL_SERVICE

        c[GuidelineToolAssociationStore] = GuidelineToolAssociationDocumentStore(
            guideline_tool_associations_db
        )
        c[GuidelineConnectionStore] = GuidelineConnectionDocumentStore(guideline_connections_db)
        c[SessionStore] = SessionDocumentStore(sessions_db)
        c[SessionListener] = PollingSessionListener
        c[TerminologyStore] = TerminologyChromaStore(
            ChromaDatabase(LOGGER, EMCIE_HOME_DIR), embedder_type=Large3Embedder
        )

        c[EvaluationStore] = EvaluationDocumentStore(evaluations_db)

        c[GuidelineProposer] = GuidelineProposer(
            c[Logger],
            c[BaseSchematicGenerator[GuidelinePropositionsSchema]],
        )
        c[GuidelineConnectionProposer] = GuidelineConnectionProposer(
            c[Logger],
            c[BaseSchematicGenerator[GuidelineConnectionPropositionsSchema]],
        )
        c[ToolEventProducer] = ToolEventProducer(
            c[Logger],
            c[ContextualCorrelator],
            c[ToolService],
            c[BaseSchematicGenerator[ToolCallInferenceSchema]],
        )
        c[MessageEventProducer] = MessageEventProducer(
            c[Logger],
            c[ContextualCorrelator],
            c[BaseSchematicGenerator[MessageEventSchema]],
        )

        c[CoherenceChecker] = CoherenceChecker(
            c[Logger],
            c[BaseSchematicGenerator[ContradictionTestsSchema]],
        )

        c[BehavioralChangeEvaluator] = BehavioralChangeEvaluator(
            c[Logger],
            c[EvaluationStore],
            c[GuidelineStore],
            c[GuidelineConnectionProposer],
            c[CoherenceChecker],
        )

        c[Engine] = AlphaEngine

        for loader in load_agents, load_tools, load_guidelines:
            await loader(c, config)

        async with MC(c) as mc:
            c[MC] = mc
            yield c


async def recover_server_tasks(
    evaluation_store: EvaluationStore,
    evaluator: BehavioralChangeEvaluator,
) -> None:
    for evaluation in await evaluation_store.list_evaluations():
        if evaluation.status in [EvaluationStatus.PENDING, EvaluationStatus.RUNNING]:
            await evaluator.run_evaluation(evaluation)


@asynccontextmanager
async def load_app(params: CLIParams) -> AsyncIterator[FastAPI]:
    global EXIT_STACK

    EXIT_STACK = AsyncExitStack()

    async with setup_container(params.config) as container, EXIT_STACK:
        indexer = Indexer(
            index_file=EMCIE_HOME_DIR / "index.json",
            logger=container[Logger],
            guideline_store=container[GuidelineStore],
            guideline_connection_store=container[GuidelineConnectionStore],
            agent_store=container[AgentStore],
            guideline_connection_proposer=container[GuidelineConnectionProposer],
        )

        if not params.index:
            if params.force:
                LOGGER.warning("Skipping indexing. This might cause unpredictable behavior.")

            elif await indexer.should_index():
                raise StartupError("indexing needs to be perform.")
        else:
            await indexer.index()

        await recover_server_tasks(
            evaluation_store=container[EvaluationStore],
            evaluator=container[BehavioralChangeEvaluator],
        )

        yield await create_app(container)


async def serve_app(
    app: FastAPI,
    port: int,
    should_hot_reload: Callable[[], Awaitable[bool]],
) -> ShutdownReason:
    config = uvicorn.Config(app, host="0.0.0.0", port=port, log_level="info")
    server = uvicorn.Server(config)
    interrupted = False

    async def monitor_shutdown_request() -> ShutdownReason:
        try:
            while True:
                await asyncio.sleep(1)

                if await should_hot_reload():
                    server.should_exit = True
                    return ShutdownReason.HOT_RELOAD
                elif interrupted:
                    return ShutdownReason.SHUTDOWN_REQUEST
        except asyncio.CancelledError:
            return ShutdownReason.SHUTDOWN_REQUEST

    shutdown_monitor_task = asyncio.create_task(monitor_shutdown_request())

    try:
        await server.serve()
        interrupted = True
    except (KeyboardInterrupt, asyncio.CancelledError):
        return ShutdownReason.SHUTDOWN_REQUEST
    except BaseException as e:
        LOGGER.critical(e.__class__.__name__ + ": " + str(e))
        sys.exit(1)

    return await shutdown_monitor_task


async def start_server(params: CLIParams) -> None:
    assert ConfigurationFileValidator(LOGGER).validate(config_file=params.config_file)

    last_config_update_time = params.config_file.stat().st_mtime

    async def config_file_changed() -> bool:
        nonlocal last_config_update_time
        current_mtime = params.config_file.stat().st_mtime

        if current_mtime > last_config_update_time:
            validated = ConfigurationFileValidator(LOGGER).validate(config_file=params.config_file)

            last_config_update_time = current_mtime

            return validated

        return False

    while True:
        async with load_app(params) as app:
            shutdown_reason = await serve_app(
                app,
                params.port,
                should_hot_reload=config_file_changed,
            )

            if shutdown_reason == ShutdownReason.SHUTDOWN_REQUEST:
                return
            elif shutdown_reason == ShutdownReason.HOT_RELOAD:
                LOGGER.info("***** HOT RELOAD *****")

                with open(params.config_file) as f:
                    params.config = json.load(f)
                    last_config_update_time = params.config_file.stat().st_mtime


async def check_coherence(params: CLIParams) -> None:
    def render_guideline(g: GuidelineContent) -> str:
        return f"When {g.predicate}, then {g.action}"

    checker = CoherenceChecker(
        LOGGER,
        GPT4o(logger=LOGGER, schema=ContradictionTestsSchema),
    )

    for agent, guideline_specs in params.config["guidelines"].items():
        guideline_to_evaluate = [
            GuidelineContent(
                predicate=str(guideline["when"]),
                action=str(guideline["then"]),
            )
            for guideline in guideline_specs
        ]

        tests = [
            t
            for t in await checker.evaluate_coherence(
                guidelines_to_evaluate=guideline_to_evaluate,
            )
            if t.severity >= 6
        ]

        if tests:
            rich.print(Text(f'{len(tests)} issues found in "{agent}"\n', style="bold red"))
            entries = [
                {
                    "first": render_guideline(t.guideline_a),
                    "second": render_guideline(t.guideline_b),
                    "issue": t.rationale,
                    "severity": t.severity,
                }
                for t in tests
            ]
            rich.print(
                tabulate(
                    entries,
                    headers="keys",
                    maxcolwidths=[20, 20, 40, 10],
                    tablefmt="rounded_grid",
                )
            )
            rich.print()


if __name__ == "__main__":
    click_completion.init()

    @click.group
    @click.option(
        "-c",
        "--config-file",
        type=str,
        help="Server configuration file",
        metavar="FILE",
        required=True,
        default=EMCIE_HOME_DIR / "config.json",
    )
    @click.pass_context
    def cli(ctx: click.Context, config_file: str) -> None:
        if not ctx.obj:
            config_file_path = Path(config_file)

            if not config_file_path.exists():
                print(f"error: config file not found: {config_file_path}", file=sys.stderr)
                sys.exit(1)

            with open(config_file_path, "r") as f:
                config = json.load(f)

                ctx.obj = CLIParams(
                    config_file=config_file_path,
                    config=config,
                    port=DEFAULT_PORT,
                    index=False,
                    force=True,
                )

    @cli.command(help="Run the Emcie server")
    @click.option(
        "-p",
        "--port",
        type=int,
        default=DEFAULT_PORT,
        help="Server port",
    )
    @click.option(
        "--index/--no-index",
        type=bool,
        show_default=True,
        default=False,
        help="Index configuration changes on startup",
    )
    @click.option(
        "-f",
        "--force",
        type=bool,
        default=False,
        is_flag=True,
        help="Ignore warnings and checks",
    )
    @click.pass_context
    def run(ctx: click.Context, port: int, index: bool, force: bool) -> None:
        ctx.obj.port = port
        ctx.obj.index = index
        ctx.obj.force = force
        asyncio.run(start_server(ctx.obj))

    @cli.command(help="Check the configuration's validity and coherence")
    @click.pass_context
    def check(ctx: click.Context) -> None:
        asyncio.run(check_coherence(ctx.obj))

    try:
        cli()
    except StartupError as e:
        print(f"error: {e}", file=sys.stderr)
        sys.exit(1)
