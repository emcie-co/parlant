#!/usr/bin/python3
# mypy: disable-error-code=import-untyped

import asyncio
from dataclasses import dataclass
import os
from typing import Any, Optional
from urllib.parse import urljoin
import click
import click.shell_completion
import click_completion
import requests
import rich
from rich.text import Text
from tabulate import tabulate
from textwrap import wrap

from emcie.server.core.sessions import Event


class Actions:
    @staticmethod
    def list_agents(ctx: click.Context) -> list[dict[str, Any]]:
        response = requests.get(urljoin(ctx.obj.server_address, "agents"))
        response.raise_for_status()
        return response.json()["agents"]  # type: ignore

    @staticmethod
    def create_session(
        ctx: click.Context,
        agent_id: str,
        end_user_id: str,
        title: Optional[str] = None,
    ) -> dict[str, Any]:
        response = requests.post(
            urljoin(ctx.obj.server_address, "sessions"),
            json={
                "agent_id": agent_id,
                "end_user_id": end_user_id,
                "title": title,
            },
        )

        response.raise_for_status()

        return response.json()  # type: ignore

    @staticmethod
    def list_events(ctx: click.Context, session_id: str) -> dict[str, Any]:
        response = requests.get(urljoin(ctx.obj.server_address, f"sessions/{session_id}/events"))
        response.raise_for_status()
        return response.json()["events"]  # type: ignore

    @staticmethod
    def create_event(ctx: click.Context, session_id: str, message: str) -> dict[str, Any]:
        response = requests.post(
            urljoin(ctx.obj.server_address, f"sessions/{session_id}/events"),
            json={"content": message},
        )

        response.raise_for_status()

        return response.json()  # type: ignore


class Interface:
    @staticmethod
    def list_agents(ctx: click.Context) -> None:
        agents = Actions.list_agents(ctx)

        if not agents:
            rich.print("No data available")
            return

        rich.print(tabulate(agents, headers="keys"))

    @staticmethod
    def view_session(ctx: click.Context, session_id: str) -> None:
        events = Actions.list_events(ctx, session_id)

        if not events:
            rich.print("No data available")
            return

        print(
            tabulate(
                [
                    {
                        "id": e["id"],  # type: ignore
                        "source": e["source"],  # type: ignore
                        "offset": e["offset"],  # type: ignore
                        "creation_utc": e["creation_utc"],  # type: ignore
                        "message": e["data"]["message"],  # type: ignore
                    }
                    for e in events
                ],
                headers="keys",
                maxcolwidths=[None, None, None, None, 40],
            )
        )

    @staticmethod
    def create_session(
        ctx: click.Context,
        agent_id: str,
        end_user_id: str,
        title: Optional[str] = None,
    ) -> None:
        session = Actions.create_session(ctx, agent_id, end_user_id, title)
        print(tabulate([session], headers="keys"))

    @staticmethod
    def create_event(ctx: click.Context, session_id: str, message: str) -> None:
        event = Actions.create_event(ctx, session_id, message)
        rich.print(tabulate([event], headers="keys"))

    @staticmethod
    def chat(ctx: click.Context, session_id: str) -> None:
        def print_message(message_event: dict[str, Any]) -> None:
            role = {"client": "User", "server": "Agent"}[m["source"]]
            prefix = Text(
                f"{role}:".ljust(6), style="bold " + {"User": "blue", "Agent": "green"}[role]
            )

            message = wrap(
                message_event["data"]["message"], subsequent_indent=" " * (1 + len(prefix))
            )

            rich.print(prefix, os.linesep.join(message))

        rich.print(Text("Press CTRL+C at any time to quit\n", style="bold"))

        response = requests.get(urljoin(ctx.obj.server_address, f"sessions/{session_id}/events"))
        response.raise_for_status()

        message_events = [e for e in response.json()["events"] if e["kind"] == Event.MESSAGE_KIND]

        max_number_of_history_events_to_show = 5

        if len(message_events) > max_number_of_history_events_to_show:
            rich.print(
                f"(skipping {len(message_events) - max_number_of_history_events_to_show} "
                "event(s) in history...)\n",
                flush=True,
            )
            message_events = message_events[-max_number_of_history_events_to_show:]

        for m in message_events:
            print_message(m)

        while True:
            try:
                rich.print(Text("User:  ", style="bold blue"), end="")
                new_message = input()

                response = requests.post(
                    urljoin(ctx.obj.server_address, f"sessions/{session_id}/events"),
                    json={"content": new_message},
                )
                response.raise_for_status()
                new_event = response.json()

                last_known_offset = new_event["event_offset"]

                while True:
                    response = requests.get(
                        urljoin(
                            ctx.obj.server_address,
                            f"sessions/{session_id}/events"
                            f"?min_offset={1 + last_known_offset}&wait=true",
                        )
                    )

                    if response.status_code == 504:
                        # Timeout occurred; try again
                        continue

                    events = response.json()["events"]
                    last_known_offset = events[-1]["offset"]

                    # TODO: This current implementation does not support async polling mode,
                    #       but rather relies on request/response, which isn't comprehensive.
                    if message_events := [
                        e for e in response.json()["events"] if e["kind"] == Event.MESSAGE_KIND
                    ]:
                        for m in message_events:
                            print_message(m)
                        break

            except KeyboardInterrupt:
                rich.print("\nQuitting...", flush=True)
                return


async def main() -> None:
    click_completion.init()

    @dataclass(frozen=True)
    class Config:
        server_address: str

    @click.group
    @click.option(
        "-s", "--server", type=str, help="Server address", metavar="ADDRESS[:PORT]", required=True
    )
    @click.pass_context
    def cli(ctx: click.Context, server: str) -> None:
        if not ctx.obj:
            ctx.obj = Config(server_address=server)

    @cli.command(help="Generate shell completion code")
    @click.option("-s", "--shell", type=str, help="Shell program (bash, zsh, etc.)", required=True)
    def complete(shell: str) -> None:
        click.echo(click_completion.get_code(shell))

    @cli.group(help="Manage agents")
    def agent() -> None:
        pass

    @agent.command("list", help="List agents")
    @click.pass_context
    def agent_list(ctx: click.Context) -> None:
        Interface.list_agents(ctx)

    @agent.command(
        "chat",
        help="Jump into a chat with an agent\n\n"
        "If AGENT_ID is omitted, the default agent will be selected.",
    )
    @click.argument("agent_id", required=False)
    @click.pass_context
    def agent_chat(ctx: click.Context, agent_id: Optional[str]) -> None:
        if not agent_id:
            agents = Actions.list_agents(ctx)
            assert agents
            agent_id = agents[0]["id"]

        assert agent_id

        session = Actions.create_session(ctx, agent_id=agent_id, end_user_id="<unused>")

        Interface.chat(ctx, session["session_id"])

    @cli.group(help="Manage sessions")
    def session() -> None:
        pass

    @session.command("new", help="Create a new session")
    @click.option("-a", "--agent-id", type=str, help="Agent ID", metavar="ID", required=True)
    @click.option("-u", "--end-user-id", type=str, help="End User ID", metavar="ID", required=True)
    @click.option("-t", "--title", type=str, help="Session Title", metavar="TITLE", required=False)
    @click.pass_context
    def session_new(
        ctx: click.Context,
        agent_id: str,
        end_user_id: str,
        title: Optional[str],
    ) -> None:
        Interface.create_session(ctx, agent_id, end_user_id, title)

    @session.command("view", help="View session content")
    @click.argument("session_id")
    @click.pass_context
    def session_view(ctx: click.Context, session_id: str) -> None:
        Interface.view_session(ctx, session_id)

    @session.command("post", help="Post user message to session")
    @click.argument("session_id")
    @click.argument("message")
    @click.pass_context
    def session_post(ctx: click.Context, session_id: str, message: str) -> None:
        Interface.create_event(ctx, session_id, message)

    @session.command("chat", help="Enter chat mode within the session")
    @click.argument("session_id")
    @click.pass_context
    def session_chat(ctx: click.Context, session_id: str) -> None:
        Interface.chat(ctx, session_id)

    cli()


if __name__ == "__main__":
    asyncio.run(main())
